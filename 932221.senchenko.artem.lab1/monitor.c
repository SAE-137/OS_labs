// Подключаем заголовки POSIX-потоков и базовые функции ввода/вывода

#include <pthread.h>   // pthread_t, pthread_create, pthread_mutex_*, pthread_cond_*
#include <stdio.h>     // printf
#include <unistd.h>    // sleep

// Эта структура — "полезная нагрузка" (данные события).
// В реальной задаче тут мог бы быть сложный объект, указатель и т.д.
// В лабораторной достаточно целого числа.

struct Payload {
    int value;
};

// Это — наш "монитор" в терминах задания.
// В классическом понимании монитор = данные + средства синхронизации.
// Здесь:
//  - mutex защищает доступ к разделяемым данным,
//  - cond позволяет потоку ждать наступления события,
//  - ready — флаг наличия события,
//  - payload — сами данные события.

struct Monitor {
    pthread_mutex_t mutex;   // мьютекс: защищает доступ к shared данным
    pthread_cond_t  cond;    // условная переменная: ожидание/сигнал события
    int ready;               // флаг: 0 — события нет, 1 — событие готово
    struct Payload payload;  // разделяемые данные (событие)
};

// --------- ФУНКЦИЯ ПОТОКА-ПРОИЗВОДИТЕЛЯ ---------

// Функция потока должна иметь тип: void* (void*)
// arg — это указатель, который мы передаём из main (у нас это &monitor)
void* producer(void* arg) {
    // Приводим общий void* к нужному типу — указателю на Monitor.
    struct Monitor* m = (struct Monitor*)arg;

    int counter = 0;  // локальный счетчик событий

    // Бесконечный цикл — производитель работает постоянно,
    // каждую секунду создаёт новое "событие"
    for (;;) {
        // Задержка 1 секунда — требование задания
        sleep(1);

        // Входим в критическую секцию: блокируем мьютекс,
        // чтобы только этот поток мог сейчас менять ready/payload.
        pthread_mutex_lock(&m->mutex);

        // Если предыдущее событие ещё не обработано (ready == 1),
        // то НЕ перезаписываем данные, а аккуратно выходим.
        if (m->ready) {
            // Освобождаем мьютекс, чтобы не блокировать потребителя
            pthread_mutex_unlock(&m->mutex);
            // Пропускаем итерацию, подождём ещё секунду
            continue;
        }

        // Здесь гарантированно ready == 0, можно записать новое "событие".
        // Меняем данные в payload под защитой мьютекса.
        m->payload.value = counter++;  // записали значение и увеличили счётчик

        // Отмечаем, что событие готово для потребителя
        m->ready = 1;

        // Выводим сообщение о том, что событие "отправлено".
        // ptr показывает адрес payload — это иллюстрирует, что передаём
        // один и тот же объект по указателю (несериализуемые данные).
        printf("producer: sent event, value=%d, ptr=%p\n",
               m->payload.value, (void*)&m->payload);

        // Сигнализируем условной переменной:
        // если поток-потребитель спит в pthread_cond_wait, он проснётся.
        pthread_cond_signal(&m->cond);

        // Выходим из критической секции, освобождаем мьютекс.
        pthread_mutex_unlock(&m->mutex);
    }

    // Формально нужно что-то вернуть, хотя код сюда никогда не дойдёт,
    // потому что цикл бесконечный.
    return NULL;
}

// --------- ФУНКЦИЯ ПОТОКА-ПОТРЕБИТЕЛЯ ---------

void* consumer(void* arg) {
    // Аналогично производителю, получаем указатель на Monitor
    struct Monitor* m = (struct Monitor*)arg;

    // Потребитель тоже работает бесконечно,
    // ожидая новые события от производителя.
    for (;;) {
        // Захватываем мьютекс перед работой с разделяемыми данными.
        pthread_mutex_lock(&m->mutex);

        // Классический паттерн работы с условной переменной:
        // while (!условие) pthread_cond_wait(...)
        // Здесь условие — "есть готовое событие" (m->ready != 0).
        while (!m->ready) {
            // pthread_cond_wait делает две вещи:
            //  1) временно отпускает мьютекс (mutex),
            //  2) усыпляет поток до прихода сигнала cond.
            //
            // Когда придёт сигнал (pthread_cond_signal),
            // поток проснётся и вновь захватит мьютекс
            // перед выходом из pthread_cond_wait.
            pthread_cond_wait(&m->cond, &m->mutex);
        }

        // Когда мы вышли из while, событие гарантированно есть (ready == 1).
        // Берём указатель на payload — это и есть "несериализуемые данные",
        // с которыми мы работаем по указателю, а не копируем.
        struct Payload* p = &m->payload;

        // Выводим значение и адрес событийных данных.
        printf("consumer: got event, value=%d, ptr=%p\n",
               p->value, (void*)p);

        // Помечаем, что событие обработано.
        // Теперь производитель сможет создать новое.
        m->ready = 0;

        // Освобождаем мьютекс, выходим из критической секции.
        pthread_mutex_unlock(&m->mutex);
    }

    return NULL;
}

// --------- ФУНКЦИЯ main ---------

int main(void) {
    // Создаём один экземпляр монитора и инициализируем его поля.
    // PTHREAD_MUTEX_INITIALIZER и PTHREAD_COND_INITIALIZER —
    // стандартные макросы для статической инициализации мьютекса и cond.
    struct Monitor monitor = {
        .mutex = PTHREAD_MUTEX_INITIALIZER,
        .cond  = PTHREAD_COND_INITIALIZER,
        .ready = 0              // поначалу события нет
        // payload.value здесь можно не инициализировать, всё равно
        // потребитель не прочитает его до ready=1
    };

    // Переменные для идентификаторов потоков
    pthread_t prod_thread;
    pthread_t cons_thread;

    // Создаём поток-производитель.
    // Аргументом передаём &monitor, чтобы поток работал с теми же данными.
    pthread_create(&prod_thread, NULL, producer, &monitor);

    // Создаём поток-потребитель с тем же монитором.
    pthread_create(&cons_thread, NULL, consumer, &monitor);

    // Ожидаем завершения потоков.
    // В данном случае они бесконечные, поэтому программа работает,
    // пока пользователь не прервёт её (Ctrl+C).
    pthread_join(prod_thread, NULL);
    pthread_join(cons_thread, NULL);

    return 0;
}
